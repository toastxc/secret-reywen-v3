use iso8601_timestamp::Timestamp;
use reywen_http::utils::if_false;
use serde::{Deserialize, Serialize};

use crate::structures::{
    media::{attachment::File, embeds::Embed},
    server::server_member::Member,
    users::user::User,
};

#[derive(Serialize, Deserialize, Clone, Debug, Default)]
pub struct Reply {
    /// Message Id
    pub id: String,
    /// Whether this reply should mention the message's author
    pub mention: bool,
}
/// Representation of a text embed before it is sent.
#[derive(Serialize, Deserialize, Clone, Debug, Default)]
pub struct SendableEmbed {
    pub icon_url: Option<String>,
    pub url: Option<String>,
    pub title: Option<String>,
    pub description: Option<String>,
    pub media: Option<String>,
    pub colour: Option<String>,
}
/// Representation of a system event message
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum SystemMessage {
    #[serde(rename = "text")]
    Text { content: String },
    #[serde(rename = "user_added")]
    UserAdded { id: String, by: String },
    #[serde(rename = "user_remove")]
    UserRemove { id: String, by: String },
    #[serde(rename = "user_joined")]
    UserJoined { id: String },
    #[serde(rename = "user_left")]
    UserLeft { id: String },
    #[serde(rename = "user_kicked")]
    UserKicked { id: String },
    #[serde(rename = "user_banned")]
    UserBanned { id: String },
    #[serde(rename = "channel_renamed")]
    ChannelRenamed { name: String, by: String },
    #[serde(rename = "channel_description_changed")]
    ChannelDescriptionChanged { by: String },
    #[serde(rename = "channel_icon_changed")]
    ChannelIconChanged { by: String },
    #[serde(rename = "channel_ownership_changed")]
    ChannelOwnershipChanged { from: String, to: String },
}

/// Name and / or avatar override information
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Masquerade {
    /// Replace the display name shown on this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Replace the avatar shown on this message (URL to image file)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar: Option<String>,
    /// Replace the display role colour shown on this message
    ///
    /// Must have `ManageRole` permission to use
    #[serde(skip_serializing_if = "Option::is_none")]
    pub colour: Option<String>,
}

impl Masquerade {
    pub fn set_name(&mut self, name: &str) -> Self {
        self.name = Some(String::from(name));
        self.to_owned()
    }
    pub fn set_avatar(&mut self, avatar: &str) -> Self {
        self.avatar = Some(String::from(avatar));
        self.to_owned()
    }
    pub fn set_color(&mut self, color: &str) -> Self {
        self.colour = Some(String::from(color));
        self.to_owned()
    }
    pub fn set_colour(&mut self, color: &str) -> Self {
        self.colour = Some(String::from(color));
        self.to_owned()
    }
    pub fn new() -> Self {
        Default::default()
    }
}

/// Information to guide interactions on this message
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Interactions {
    /// Reactions which should always appear and be distinct
    //#[serde(skip_serializing_if = "Option::is_none")]
    //  pub reactions: Option<IndexSet<String>>,
    /// Whether reactions should be restricted to the given list
    ///
    /// Can only be set to true if reactions list is of at least length 1
    #[serde(skip_serializing_if = "if_false")]
    pub restrict_reactions: bool,
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Message {
    /// Unique Id
    #[serde(rename = "_id")]
    pub id: String,
    /// Unique value generated by client sending this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<String>,
    /// Id of the channel this message was sent in
    pub channel: String,
    /// Id of the user that sent this message
    pub author: String,

    /// Message content
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,
    /// System message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system: Option<SystemMessage>,
    /// Array of attachments
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Vec<File>>,
    /// Time at which this message was last edited
    #[serde(skip_serializing_if = "Option::is_none")]
    pub edited: Option<Timestamp>,
    /// Attached embeds to this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embeds: Option<Vec<Embed>>,
    /// Array of user ids mentioned in this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mentions: Option<Vec<String>>,
    /// Array of message ids this message is replying to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replies: Option<Vec<String>>,
    /// Hashmap of emoji IDs to array of user IDs
    //  #[serde(skip_serializing_if = "IndexMap::is_empty", default)]
    // pub reactions: IndexMap<String, IndexSet<String>>,
    /// Information about how this message should be interacted with
    // #[serde(skip_serializing_if = "Interactions::is_default", default)]
    // pub interactions: Interactions,
    /// Name and / or avatar overrides for this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub masquerade: Option<Masquerade>,
}
/// # Message Sort
///
/// Sort used for retrieving messages
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub enum MessageSort {
    /// Sort by the most relevant messages
    #[default]
    Relevance,
    /// Sort by the newest messages first
    Latest,
    /// Sort by the oldest messages first
    Oldest,
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum MessageTimePeriod {
    Relative {
        /// Message id to search around
        ///
        /// Specifying 'nearby' ignores 'before', 'after' and 'sort'.
        /// It will also take half of limit rounded as the limits to each side.
        /// It also fetches the message ID specified.
        nearby: String,
    },
    Absolute {
        /// Message id before which messages should be fetched
        before: Option<String>,
        /// Message id after which messages should be fetched
        after: Option<String>,
        /// Message sort direction
        sort: Option<MessageSort>,
    },
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum BulkMessageResponse {
    Messages(
        /// List of messages
        Vec<Message>,
    ),
    MessagesAndUsers {
        /// List of messages
        messages: Vec<Message>,
        /// List of users
        users: Vec<User>,
        /// List of members
        #[serde(skip_serializing_if = "Option::is_none")]
        members: Option<Vec<Member>>,
    },
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BulkMessageResponse2 {
    /// List of messages
    #[serde(skip_serializing_if = "Option::is_none")]
    pub messages: Option<Vec<Message>>,
    /// List of users
    #[serde(skip_serializing_if = "Option::is_none")]
    pub users: Option<Vec<User>>,
    /// List of members
    #[serde(skip_serializing_if = "Option::is_none")]
    pub members: Option<Vec<Member>>,
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct AppendMessage {
    /// Additional embeds to include in this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embeds: Option<Vec<Embed>>,
}
